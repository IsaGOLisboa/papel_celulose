# Selecionar os valores de 'World' a partir da coluna 9 e converter para numérico
dados_world_imp_valores <- as.numeric(dados_world_imp[1, 9:ncol(dados_world_imp)])
# Verificação se as somas dos continentes são iguais aos valores de "World"
comparacao <- dados_imp_soma == dados_world_imp_valores
# Exibir o resultado da comparação
print(comparacao)
##################################Adicionar a coluna world para traçar o gráfico de colunas
imp_continentes_world = rbind(imp_continentes, dados_world_imp)
#Grafico comparativo entre produções
imp_long <- melt(imp_continentes_world, id.vars = "Area",
measure.vars = colnames(imp_continentes_world)[9:ncol(imp_continentes_world)],
variable.name = "Ano", value.name = "Importacao")
# Convertendo a coluna 'Ano' para numérico
imp_long$Ano <- as.numeric(as.character(imp_long$Ano))
# Criar o gráfico de barras com ggplot2
p <- ggplot(imp_long, aes(x = Ano, y = Importacao, fill = Area)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Importações por Continentes",
x = "Ano", y = "Imprtações (t)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set2")
# Transformar o gráfico em interativo com ggplotly
ggplotly(p)
############# análise gráfica para importação
# Filtrar apenas as áreas desejadas
areas_desejadas <- c("United States of America", "China", "Brazil", "Canada", "Sweden", "Finland", "
Indonesia", "Russian Federation", "Japan", "India")
# Criar um novo DataFrame com as áreas selecionadas
imp_paises <- subset(imp_filtrados, Area %in% areas_desejadas)
# Verificar e converter as colunas para numérico (exceto a primeira coluna 'Area')
imp_paises[, 9:ncol(imp_paises)] <- lapply(imp_paises[, 9:ncol(imp_paises)], function(x) as.numeric(as.character(x)))
imp_paises<- rbind(imp_paises, dados_world_imp)
colnames(imp_paises)
# Selecionar as colunas
colunas_selecionadas <- c("1961", "1970", "1980", "1990", "2000", "2010", "2020","2021", "2022")
# Derreter (melt) os dados para o formato longo, com as colunas selecionadas
imp_long <- melt(imp_paises[,  c("Area", colunas_selecionadas)],
id.vars = "Area",
variable.name = "Ano",
value.name = "Importacao")
# Convertendo a coluna 'Ano' para numérico, se necessário
imp_long$Ano <- as.numeric(as.character(imp_long$Ano))
# Filtrar os dados para remover a observação 'World'
imp_long_sem_world <- subset(imp_long, Area != "World")
# Reordenar as áreas com base na produção (maior para menor)
imp_long_sem_world <- imp_long_sem_world %>%
group_by(Ano) %>%
arrange(desc(Importacao), .by_group = TRUE)
# Criar o gráfico de barras com barras mais largas e ordenadas
p <- ggplot(imp_long_sem_world, aes(x = Ano, y = Importacao, fill = Area)) +
geom_bar(stat = "identity", position = "dodge", width = 0.8) +
labs(title = "Importações por país",
x = "Ano", y = "Importações (t)") +
scale_x_continuous(breaks = as.numeric(colunas_selecionadas)) +  # Incluir os anos selecionados no eixo X
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_brewer(palette = "Set3")  # Usando uma paleta com mais cores
# Transformar o gráfico em interativo com ggplotly
ggplotly(p)
# Dividir o gráfico em várias facetas (um para cada país)
p <- ggplot(imp_long_sem_world, aes(x = Ano, y = Importacao, fill = Area)) +
geom_bar(stat = "identity", position = "dodge", width = 0.5) +
labs(title = "Importações por País", x = "Ano", y = "Importações") +
facet_wrap(~ Area, scales = "free_y") +  # Dividir em facetas, um gráfico para cada país
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Transformar o gráfico em interativo com ggplotly
ggplotly(p)
#####################balança comercial de papel e celulose
# Fazer o merge dos dois DataFrames com base na coluna 'Area', mantendo todas as colunas
dados_combinados <- merge(exp_filtrados, imp_filtrados, by = "Area", suffixes = c("_exp", "_imp"))
# Identificar as colunas a partir da posição 9 (supondo que sejam as mesmas em ambos os DataFrames)
colunas_selecionadas <- colnames(exp_filtrados)[9:ncol(exp_filtrados)]
# Criar o DataFrame balanca_comercial e manter todas as colunas do merge
balanca_comercial <- dados_combinados
# Calcular a diferença para as colunas a partir da posição 9
for (col in colunas_selecionadas) {
col_exp <- paste0(col, "_exp")
col_imp <- paste0(col, "_imp")
# Verificar se as colunas existem no DataFrame combinado e se ambas têm o mesmo número de valores
if (col_exp %in% colnames(dados_combinados) && col_imp %in% colnames(dados_combinados)) {
# Garantir que os valores são numéricos e realizar a subtração
balanca_comercial[[col]] <- as.numeric(dados_combinados[[col_exp]]) - as.numeric(dados_combinados[[col_imp]])
}
}
# Exibir as primeiras linhas do DataFrame balanca_comercial
head(balanca_comercial)
# Selecionar a coluna 'Area' e as colunas que possuem apenas números (sem sufixos)
balanca_comercial_limpo <- balanca_comercial[, c("Area", grep("^[0-9]+$", colnames(balanca_comercial), value = TRUE))]
# Exibir as primeiras linhas do DataFrame limpo
head(balanca_comercial_limpo)
# Filtrar os dados para os países de 'areas_desejadas'
dados_filtrados_balanca <- balanca_comercial_limpo[balanca_comercial_limpo$Area %in% areas_desejadas, ]
dados_long <- melt(dados_filtrados_balanca, id.vars = "Area", variable.name = "Ano", value.name = "Balanca")
# Criar o gráfico de linhas interativo usando plotly
fig <- plot_ly(dados_long, x = ~Ano, y = ~Balanca , color = ~Area, type = 'scatter', mode = 'lines')
# Exibir o gráfico
fig
###########################Tipos de papel
unique(dados_FAOSTAT$Item)
# Definir os itens desejados em inglês (os que você mencionou)
itens <- c("Recovered paper",
"Paper and paperboard",
"Graphic papers",
"Newsprint",
"Paper and paperboard, excluding newsprint",
"Printing and writing papers",
"Printing and writing papers, uncoated, mechanical",
"Printing and writing papers, uncoated, wood free",
"Printing and writing papers, coated",
"Other paper and paperboard",
"Household and sanitary papers",
"Packaging paper and paperboard",
"Case materials",
"Cartonboard",
"Wrapping papers",
"Other papers mainly for packaging",
"Other paper and paperboard n.e.s. (not elsewhere specified)")
# Filtrar o DataFrame 'dados_FOASTAT' para manter apenas os itens desejados
df_papel <- subset(dados_FAOSTAT, Item %in% itens)
# Exibir as primeiras linhas do novo DataFrame
head(df_papel)
papel_world<- df_papel%>%
filter(Area == "World" & Element == "Production")
colunas_para_manter <- grep("^(?!.*[NF]$)", names(papel_world), value = TRUE, perl = TRUE)
# Cria um novo DataFrame com as colunas filtradas
papel_world <-papel_world[, colunas_para_manter]
colnames(papel_world)<-gsub("^Y", "", colnames(papel_world))
# Filtrar os dados para as observações especificadas
# Filtrar os dados para as observações especificadas
itens_desejados <- c("Graphic papers", "Newsprint",
"Printing and writing papers", "Other paper and paperboard",
"Household and sanitary papers", "Packaging paper and paperboard",
"Case materials", "Cartonboard", "Wrapping papers",
"Other papers mainly for packaging", "Other paper and paperboard n.e.s.")
df_filtrado <- subset(papel_world, Item %in% itens_desejados)
# Selecionar as colunas a partir da posição 9 (anos de 1961 a 2022)
colunas_anos <- colnames(df_filtrado)[9:ncol(df_filtrado)]
# Transformar o DataFrame para o formato longo (long format)
df_long <- melt(df_filtrado, id.vars = "Item", measure.vars = colunas_anos,
variable.name = "Ano", value.name = "Valor")
# Converter a coluna 'Ano' para numérico
df_long$Ano <- as.numeric(as.character(df_long$Ano))
df_long<-df_long[df_long$Ano>=2000, ]
# Criar o gráfico de pizza animado
fig <- plot_ly(df_long, labels = ~Item, values = ~Valor, type = 'pie', frame = ~Ano,
textinfo = 'label+percent', hoverinfo = 'label+value') %>%
layout(title = 'Distribuição de Papéis e Papelões ao longo dos anos',
updatemenus = list(
list(type = "buttons",
buttons = list(
list(method = "animate",
args = list(NULL, list(frame = list(duration = 1000, redraw = TRUE),
transition = list(duration = 500))),
label = "Play")
)
)
))
# Exibir o gráfico
fig
paper_for_type_22<- subset(df_long,Ano == "2022" )
##############consumo de papel por paises
dados_pulp_for_paper_prod
dados_pulp_for_paper_exp
dados_pulp_for_paper_imp
# consumo = Produção + importação - exportação
# Selecionando os dados de interesse
dados_pulp_for_paper_prod_limpo <- dados_pulp_for_paper_prod[dados_pulp_for_paper_prod$Element == "Production", -c(1, 2, 4, 5, 6)]
dados_pulp_for_paper_imp_limpo <- dados_pulp_for_paper_imp[dados_pulp_for_paper_imp$Element == "Import Quantity", -c(1, 2, 4, 5, 6)]
dados_pulp_for_paper_exp_limpo <- dados_pulp_for_paper_exp[dados_pulp_for_paper_exp$Element == "Export Quantity", -c(1, 2, 4, 5, 6)]
print(dim(dados_pulp_for_paper_exp_limpo))  # Exportação
print(dim(dados_pulp_for_paper_imp_limpo))  # Importação
print(dim(dados_pulp_for_paper_prod_limpo)) # Produção
# Realizar o merge utilizando a coluna 'Area' como chave, garantindo que todos os dados sejam combinados corretamente
dados_merged <- merge(dados_pulp_for_paper_prod_limpo, dados_pulp_for_paper_imp_limpo, by = "Area", all = TRUE, suffixes = c("_prod", "_imp"))
dados_merged <- merge(dados_merged, dados_pulp_for_paper_exp_limpo, by = "Area", all = TRUE, suffixes = c("", "_exp"))
# Substituir os valores NA por 0 para as colunas de produção, importação e exportação
anos <- paste0(1961:2022)
for (ano in anos) {
dados_merged[[paste0(ano, "_prod")]] <- ifelse(is.na(dados_merged[[paste0(ano, "_prod")]]), 0, dados_merged[[paste0(ano, "_prod")]])
dados_merged[[paste0(ano, "_imp")]] <- ifelse(is.na(dados_merged[[paste0(ano, "_imp")]]), 0, dados_merged[[paste0(ano, "_imp")]])
dados_merged[[ano]] <- ifelse(is.na(dados_merged[[ano]]), 0, dados_merged[[ano]])  # Exportação
}
# Criar o DataFrame final 'consumo' apenas com a coluna 'Area' e os resultados calculados para cada ano
consumo <- dados_merged[, "Area", drop = FALSE]  # Manter apenas a coluna 'Area' inicialmente
# Adicionar colunas de cálculo para cada ano
for (ano in anos) {
consumo[[ano]] <- dados_merged[[paste0(ano, "_prod")]] + dados_merged[[paste0(ano, "_imp")]] - dados_merged[[ano]]
}
write.csv(consumo, "C:\\Users\\User\\Desktop\\papel_celulose\\dfs\\consumo_polpa_celulose_por_pais.csv")
# Filtrando apenas as linhas onde Area é igual a 'China'
consumo_china <- subset(consumo, Area == "China")
prod_china<- subset(dados_pulp_for_paper_prod_limpo, Area =="China")
import_china <- subset(dados_pulp_for_paper_imp_limpo, Area =="China")
export_china <- subset(dados_pulp_for_paper_exp_limpo, Area =="China")
print(consumo_china)
print(prod_china)
print(import_china)
print(export_china)
#####Calculando o consumo per capto
populacao_por_pais<- read.csv("C:\\Users\\User\\Desktop\\papel_celulose\\dfs\\populacao_por_pais.csv")
# Remover o prefixo "X" dos nomes das colunas de populacao_por_pais
colnames(populacao_por_pais) <- gsub("^X", "", colnames(populacao_por_pais))
# Remover a primeira coluna de populacao_por_pais
populacao_por_pais <- populacao_por_pais[, -1]
colnames(populacao_por_pais)
# Verificar os tipos de dados das colunas no DataFrame populacao_por_pais
str(populacao_por_pais)
populacao_por_pais[colunas_anos] <- lapply(populacao_por_pais[colunas_anos], function(x) as.numeric(x))
# Verificar se a conversão foi bem-sucedida
str(populacao_por_pais)
str(consumo)
# Substituir valores 0 por NaN no DataFrame consumo (exceto na coluna 'Area')
consumo[, -1] <- lapply(consumo[, -1], function(x) ifelse(x == 0, NaN, x))
# Corrigir manualmente nomes de países no DataFrame consumo$Area
consumo$Area[consumo$Area == "United States of America"] <- "United States"
consumo$Area[consumo$Area == "C\xf4te d'Ivoire"] <- "Cote d'Ivoire"
consumo$Area[consumo$Area == "T\xfcrkiye"] <- "Turkey"
consumo$Area[consumo$Area == "R\xe9union"] <- "Reunion"
consumo$Area[consumo$Area == "C\xf4te d'Ivoire"] <- "Cote d'Ivoire"
consumo$Area[consumo$Area == "Russian Federation"] <- "Russia"
consumo$Area[consumo$Area == "Venezuela (Bolivarian Republic of)"] <- "Venezuela"
consumo$Area[consumo$Area == "Iran (Islamic Republic of)"] <- "Iran"
consumo$Area[consumo$Area == "Bolivia (Plurinational State of)"] <- "Bolivia"
consumo$Area[consumo$Area == "Democratic People's Republic of Korea"] <- "North Korea"
consumo$Area[consumo$Area == "Republic of Korea"] <- "South Korea"
consumo$Area[consumo$Area == "Democratic Republic of the Congo"] <- "Congo, Dem. Rep."
consumo$Area[consumo$Area == "Congo"] <- "Congo, Rep."
print(unique(consumo$Area))
# Adicionar o sufixo _pop às colunas de anos a partir da segunda coluna em populacao_por_pais
colnames(populacao_por_pais)[-1] <- paste0(colnames(populacao_por_pais)[-1], "_pop")
# Realizar o merge utilizando 'Area' de consumo e 'Pais' de populacao_por_pais como chaves
consumo_populacao <- merge(consumo, populacao_por_pais, by.x = "Area", by.y = "Pais", all.x = TRUE)
# Verificar o resultado do merge
print(consumo_populacao)
# Remover as linhas onde todas as colunas (exceto a coluna 'Area') possuem valores NaN
consumo_populacao <- consumo_populacao[!apply(consumo_populacao[, -1], 1, function(row) all(is.na(row))), ]
# Verificar o resultado
print(consumo_populacao)
colnames(consumo_populacao)
# Lista de anos de consumo e suas correspondentes colunas de população
anos <- 1961:2022  # Sequência de anos
colunas_consumo <- as.character(anos)  # Colunas de consumo
colunas_populacao <- paste0(as.character(anos), "_pop")  # Colunas de população
# Calcular o consumo per capita para cada ano
for (ano in colunas_consumo) {
# Verificar se as colunas de consumo e população existem e não estão vazias
if (!is.null(consumo_populacao[[ano]]) && !is.null(consumo_populacao[[paste0(ano, "_pop")]])) {
# Fazer a divisão entre consumo e população, verificando se os valores são válidos
consumo_populacao[[paste0(ano, "_per_capita")]] <- ifelse(
is.na(consumo_populacao[[ano]]) | is.na(consumo_populacao[[paste0(ano, "_pop")]]) |
consumo_populacao[[ano]] == 0 | consumo_populacao[[paste0(ano, "_pop")]] == 0,
NaN,
consumo_populacao[[ano]] / consumo_populacao[[paste0(ano, "_pop")]]
)
}
}
# Remover colunas de população e consumo, mantendo apenas 'Area' e o resultado per capita
consumo_per_capita <- consumo_populacao[, c("Area", paste0(anos, "_per_capita"))]
# Verificar o resultado
print(consumo_per_capita)
# Ordenar o DataFrame com base no ano 2022 per capita, do maior para o menor
consumo_per_capita <- consumo_per_capita[order(-consumo_per_capita[["2022_per_capita"]]), ]
# Verificar o resultado final
print(consumo_per_capita)
# Remover o sufixo '_per_capita' dos nomes das colunas
colnames(consumo_per_capita) <- gsub("_per_capita", "", colnames(consumo_per_capita))
# Verificar o resultado
print(consumo_per_capita)
# Filtrando apenas as linhas onde Area é igual a 'China'
consumo_per_capta_china <- subset(consumo_per_capita,Area == "China" )
cons_china<- subset(consumo, Area =="Finland")
pop_china <- subset(populacao_por_pais, Pais =="Finland")
print(consumo_per_capta_china)
print(cons_china)
print(pop_china)
print(unique(consumo$Area))
# Multiplicar as colunas de consumo per capita por 1000, a partir da segunda coluna
consumo_per_capita[, 2:ncol(consumo_per_capita)] <- consumo_per_capita[, 2:ncol(consumo_per_capita)] * 1000
# Verificar o resultado
print(consumo_per_capita)
write.csv(consumo_per_capita, "C:\\Users\\User\\Desktop\\papel_celulose\\dfs\\consumo_per_capta.csv")
consumo_per_capta_world<- subset(consumo_per_capita, Area == "World")
##### Visualização gráfica
# Inicializar uma lista para armazenar os 10 maiores valores por ano
top10_lista <- list()
# Loop para encontrar os 10 maiores valores de consumo per capita em cada ano
for (ano in anos) {
# Obter o nome da coluna correspondente ao ano
coluna_ano <- as.character(ano)
# Ordenar os dados pelo valor do ano em ordem decrescente e pegar os 10 maiores
top10 <- consumo_per_capita[order(-consumo_per_capita[[coluna_ano]]), c("Area", coluna_ano)][1:10, ]
# Adicionar a coluna 'Ano'
top10$Ano <- ano
# Renomear a coluna de consumo per capita para um nome comum, como 'Consumo_per_capita'
colnames(top10)[2] <- "Consumo_per_capita"
# Reordenar os países por consumo per capita (para garantir a ordem correta)
top10$Area <- reorder(top10$Area, -top10$Consumo_per_capita)
# Adicionar os dados do ano na lista
top10_lista[[coluna_ano]] <- top10
}
# Combinar todas as observações em um único data frame
top10_df <- do.call(rbind, top10_lista)
# Remover observações com consumo per capita igual a 0 ou NA
top10_df <- top10_df %>% filter(!is.na(Consumo_per_capita) & Consumo_per_capita != 0)
print(unique(top10_df$Area))
#traduzido paises para Português
# Criar o mapa de tradução como uma lista
mapa_paises <- c(
"Finland" = "Finlândia",
"Sweden" = "Suécia",
"Canada" = "Canadá",
"Norway" = "Noruega",
"United States" = "Estados Unidos",
"New Zealand" = "Nova Zelândia",
"Austria" = "Áustria",
"Switzerland" = "Suíça",
"Japan" = "Japão",
"Australia" = "Austrália",
"Eswatini" = "Essuatíni",
"France" = "França",
"Germany" = "Alemanha",
"Slovenia" = "Eslovênia",
"Portugal" = "Portugal",
"Cayman Islands" = "Ilhas Cayman",
"Czechia" = "Tchéquia"
)
# Aplicar a função case_when para traduzir os valores com base no mapa
top10_df <- top10_df %>%
mutate(Area = case_when(
Area %in% names(mapa_paises) ~ mapa_paises[Area],
TRUE ~ Area
))
# Verificar o resultado
print(unique(top10_df$Area))
# Criar o gráfico de barras com os valores exibidos sobre as barras
p <- plot_ly(top10_df,
x = ~Area,
y = ~Consumo_per_capita,
frame = ~Ano,
color = ~Area,
type = "bar",
text = ~round(Consumo_per_capita, 1),  # Adicionar os valores
textposition = "outside",  # Colocar os valores fora das barras
hoverinfo = "none")  # Remover hover text
# Ajustar layout do gráfico
p <- p %>% layout(title = "Evolução temporal dos 10 países com os maiores consumos per capita de polpa para papel",
xaxis = list(title = "País", categoryorder = "total descending"),
yaxis = list(title = "Consumo per capta (kg/pessoa)"),  # Correção aqui, fechando a lista do yaxis
showlegend = TRUE)
# Configurar animação
p <- p %>% animation_opts(frame = 1000, easing = "linear", redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Year: ", font = list(color = "red")))
# Exibir gráfico
p
# Salvar o gráfico em um arquivo HTML
# Especificar o caminho completo para salvar o arquivo
htmlwidgets::saveWidget(p, "C:/Users/User/Desktop/papel_celulose/graficos/interactive_graph_consumption_country.html")
getwd()
#####Gráfico produção mundial
world_production <- read.csv("C:\\Users\\User\\Desktop\\papel_celulose\\producao_mundial.csv")
world_production<- world_production[, -c(1,2,3,5,6,7,8,9)]
colnames(world_production)<- gsub("^X", "", colnames(world_production))
colnames(world_production)
world_production <- as.data.frame(t(world_production))
world_production
colnames(world_production)
colnames(world_production)[1]<- "Production (million of tons)"
world_production$Date <- rownames(world_production)
#removendo o index
rownames(world_production) <- NULL
# Reordenando as colunas
world_production <- world_production[, c("Date", colnames(world_production)[-ncol(world_production)])]
world_production[, 2] <- as.numeric(world_production[, 2])/1000000
world_production
summary(world_production)
importacao_china<- import_china
importacao_china
importacao_china<- importacao_china[, -c(2,3)]
importacao_china<- as.data.frame(t(importacao_china))
colnames(importacao_china)
importacao_china$Date <- rownames(importacao_china)
#removendo o index
rownames(importacao_china) <- NULL
# Reordenando as colunas
importacao_china <- importacao_china[, c("Date", colnames(importacao_china)[-ncol(importacao_china)])]
importacao_china[, 2] <- as.numeric(importacao_china[, 2])/1000000
colnames(importacao_china)[2]<- "Import (millions of tons)"
importacao_china <- importacao_china[-1, ]
# Ordenando o DataFrame pelo valor da coluna 2022, do maior para o menor
dados_pulp_for_paper_imp_limpo <- dados_pulp_for_paper_imp_limpo[order(-dados_pulp_for_paper_imp_limpo$`2022`), ]
# Exibir o DataFrame ordenado
print(dados_pulp_for_paper_imp_limpo)
#China é o que mais importou em 2022
#filtrando dados de exportação do Brasil
dados_pulp_for_paper_exp_limpo
world_exp<-subset(dados_pulp_for_paper_exp_limpo, Area == "World")
world_exp
brasil_exp<- subset(dados_pulp_for_paper_exp_limpo, Area == "Brazil")
brasil_exp
world_exp<- world_exp[, -c(2,3)]
world_exp<- as.data.frame(t(world_exp))
world_exp$Date <- rownames(world_exp)
#removendo o index
rownames(world_exp) <- NULL
# Reordenando as colunas
world_exp <- world_exp[, c("Date", colnames(world_exp)[-ncol(world_exp)])]
world_exp[, 2] <- as.numeric(world_exp[, 2])/1000000
colnames(world_exp)[2]<- "Export (millions of tons)"
world_exp <- world_exp[-1, ]
world_exp
brasil_exp <- brasil_exp[, -c(2,3)]
brasil_exp <- as.data.frame(t(brasil_exp))
brasil_exp$Date <- rownames(brasil_exp)
# Removendo o index
rownames(brasil_exp) <- NULL
# Reordenando as colunas
brasil_exp <- brasil_exp[, c("Date", colnames(brasil_exp)[-ncol(brasil_exp)])]
brasil_exp[, 2] <- as.numeric(brasil_exp[, 2])/1000000
colnames(brasil_exp)[2] <- "Export (millions of tons)"
brasil_exp <- brasil_exp[-1, ]
# Exibindo o resultado
brasil_exp
#percentual de exportação do Brasil em 2022
19.150764/ 64.07008*100
# Ordenando o DataFrame pelo valor da coluna 2022, do maior para o menor
dados_pulp_for_paper_exp_limpo <- dados_pulp_for_paper_exp_limpo[order(-dados_pulp_for_paper_exp_limpo$`2022`), ]
dados_pulp_for_paper_exp_limpo
#percentual do Canadá
7.821620/64.07008*100
usa_exp<- subset(dados_pulp_for_paper_exp_limpo, Area == "United States of America")
usa_exp
#percentual USA
7.222960/64.07008*100
#percentual Indonésia
4.455051/64.07008*100
#percentual Finlandia
3.957278/64.07008*100
str(dados_pulp_for_paper_exp_limpo$`2022`)
dados_pulp_for_paper_exp_limpo$Area <- trimws(dados_pulp_for_paper_exp_limpo$Area)
# Exibindo o gráfico
p_world_production
###Grafco de linhas para world_production
p_world_production <- ggplot(world_production, aes(x = Date, y = `World_Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_continuous(breaks = c(1961, 1970, 1980, 1990, 2000, 2010, 2020, 2022)) +
theme_minimal()
# Exibindo o gráfico
p_world_production
colnames(world_production)
###Grafco de linhas para world_production
p_world_production <- ggplot(world_production, aes(x = Date, y = `Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_continuous(breaks = c(1961, 1970, 1980, 1990, 2000, 2010, 2020, 2022)) +
theme_minimal()
# Exibindo o gráfico
p_world_production
colnames(world_production)
world_production
###Grafco de linhas para world_production
world_production<- world_production[-1, ]
p_world_production <- ggplot(world_production, aes(x = Date, y = `Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_continuous(breaks = c(1961, 1970, 1980, 1990, 2000, 2010, 2020, 2022)) +
theme_minimal()
# Exibindo o gráfico
p_world_production
world_production
p_world_production <- ggplot(world_production, aes(x = Date, y = `Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_continuous(breaks = c(1961, 1970, 1980, 1990, 2000, 2010, 2020, 2022)) +
theme_minimal()
# Exibindo o gráfico
p_world_production
world_production$Date <- as.Date(as.character(world_production$Date), format="%Y")
p_world_production <- ggplot(world_production, aes(x = Date, y = `Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_continuous(breaks = c(1961, 1970, 1980, 1990, 2000, 2010, 2020, 2022)) +
theme_minimal()
# Exibindo o gráfico
p_world_production
p_world_production <- ggplot(world_production, aes(x = Date, y = `Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_continuous(breaks = c(1961, 1970, 1980, 1990, 2000, 2010, 2020, 2022)) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Girando os rótulos dos anos
# Exibindo o gráfico
p_world_production
world_production$Date <- as.Date(as.character(world_production$Date), format="%Y")
p_world_production <- ggplot(world_production, aes(x = Date, y = `Production (million of tons)`)) +
geom_line(color = "black", size = 1) +
labs(title = "Produção mundial de polpa para papel",
x = "Ano", y = "Produção (milhões t)") +
scale_x_date(breaks = as.Date(c("1961-01-01", "1970-01-01", "1980-01-01", "1990-01-01", "2000-01-01", "2010-01-01", "2020-01-01", "2022-01-01")),
date_labels = "%Y") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Exibindo o gráfico
p_world_production
